"Asm.fif" include

0x96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7 constant EMPTY_CELL_HASH

0x00000001 constant OP_CHANGE_KEY

85143  constant FN_SEQNO
71784  constant FN_LASTMSG
127202 constant FN_LASTKEY
78577  constant FN_THIRDKEY
91425  constant FN_PREVKEY
101803 constant FN_PREVMSG

33 constant ERR_SEQNO
34 constant ERR_EXP
35 constant ERR_SIG
36 constant ERR_REPLAY
37 constant ERR_UNAUTHORIZED
38 constant ERR_KEY_EXISTS
39 constant ERR_KEY_NOT_FOUND
40 constant ERR_OP_UNKNOWN

<{
	// codepage setting that costs 26 gas or more than 1%
	SETCP0

	// external message handler function id is -1
	// incrementing function id and using ifnot is cheaper
	// than otherwise equivalent comparison to -1
	DUP INC <{
		// pick external message slice
		// cut signature out of it
		// make copy of remainder (gonna need that later)
		// concatenate contract address with remainder
		// and compute hash that was signed
		OVER
		512 INT LDSLICEX
		DUP MYADDR
		NEWC STSLICE STSLICE ENDC
		HASHCU

		// take that remainder and load
		// seqno, valid until, and message cell to be sent
		SWAP 32 LDU 32 LDU PLDREF

		// unpack contract data cell
		// although first reference (if any) is last pending message
		// and second reference (if any) is previous pending message
		// load dictionary is cheaper than handling missing references
		// with main disadvantage being keys not aligned to bytes
		PUSHROOT
		CTOS 32 LDU LDDICT 256 LDU 256 LDU 256 LDU PLDDICT

		// top 5 stack items (s0...s4) are intentionally symmetrical
		//
		// s10 signature
		// s9  signed_hash
		// s8  seqno
		// s7  valid_until
		// s6  msg
		// s5  stored_seqno
		// s4  last_msg
		// s3  last_key
		// s2  third_key
		// s1  prev_key
		// s0  prev_msg

		// check valid until and compare seqnos
		s5 s8 s7 PUSH3
		NOW GEQ ERR_EXP THROWIFNOT
		EQUAL ERR_SEQNO THROWIFNOT

		<{
			// there are two return paths
			// normal (down at the very bottom) and alternative (next continuation)
			// notably alternative return is executed from nested continuations
			<{
				// alternative return path clears pending messages
				// and pushes incremented seqno on top of the stack
				DROP NULL 4 3 BLKPUSH s9 PUSH INC
			}> PUSHCONT SETEXITALT

			// checking signature against most likely used key (on top)
			s9 s10 s1 PUSH3 CHKSIGNU <{
				// if it failed then reversing top 5 items puts second most likely key
				// and its previously stored pending message (if any) on top
				5 0 REVERSE
				s9 s10 s1 PUSH3 CHKSIGNU IFRET

				// if that failed too, then it's either a third key or signature error
				s9 s10 s2 PUSH3 CHKSIGNU ERR_SIG THROWIFNOT

				// stack reordering for third key is rare and code size is prioritized
				// in order to fit external message handler into two cells

				// first attempting to swap with key that has no pending message
				// flip empty pending message slot (if any) and its key to the top
				s4 PUSH ISNULL <{ 5 0 REVERSE }> PUSHCONT IF
				// if there is an empty slot at the top, swap with its key
				s0 PUSH ISNULL <{ 2 1 REVERSE }> PUSHCONT IFJMP

				// when there are no empty slots
				// then attempting to swap with key that will *not* be confirmed
				// flip the key and message that will be confirmed to the bottom
				s0 PUSH HASHCU s7 PUSH HASHCU EQUAL <{ 5 0 REVERSE }> PUSHCONT IF
				// if message that will be confirmed is at the bottom
				// swap with key at the top
				s4 PUSH HASHCU s7 PUSH HASHCU EQUAL <{ 2 1 REVERSE }> PUSHCONT IFJMP

				// if none of the messages will be confirmed then do not send anything
				// just clear pending orders and advance seqno (alternative return)
				RETALT
			}> PUSHCONT IFNOT

			// if there is pending message submitted by another key (at the bottom)
			s4 PUSH ISNULL <{
				// compare it to one received in external message
				s4 PUSH HASHCU s7 PUSH HASHCU EQUAL IFNOTRET

				// next line severly affects performance pushing the size of external
				// message handler over two cells and should be removed in future
				//
				// succefull confirmation (they match)
				// jump to alternative return if it is empty cell (cancelation)
				s6 PUSH HASHCU EMPTY_CELL_HASH INT EQUAL IFRETALT

				// sending message, and also when previous line removed
				// sending erroneous empty cell (cancelation)
				// sending empty cell instead of valid message raises the error
				// during action phase preventing contract data from being saved
				// once flag 2 ignores that error previous line can be removed
				s6 PUSH 3 INT SENDRAWMSG

				// clear pending orders and advance seqno (alternative return)
				RETALT
			}> PUSHCONT IFNOT

			// normal return path storing message and waiting for confirmation
			// check if key did not stored message already
			s0 PUSH ISNULL ERR_REPLAY THROWIFNOT
			// swap received message with empty slot (null)
			s6 XCHG0
			// and push seqno on top without incrementing
			s5 PUSH
		}>c CALLREF // slightly cheaper than executing continuation

		// both exits from previous continuation push seqno on top of the stack
		// current key and pending message (on top) are stored near seqno
		// and will be at the bottom during next execution
		NEWC 32 STU STDICT 256 STU 256 STU 256 STU STDICT ENDC
		POPROOT
		ACCEPT
	}> PUSHCONT IFNOTJMP

	DUP <{
		// check bounced flag
		s2 PUSH CTOS 4 LDU SWAP 1 INT AND IFRET

		// simple transfer if no op field or it is zero
		s2 PUSH 32 LDUQ IFNOTRET OVER IFNOTRET

		OVER OP_CHANGE_KEY INT EQUAL <{
			s2 PUSH LDMSGADDR DROP MYADDR SDEQ ERR_UNAUTHORIZED THROWIFNOT

			PUSHROOT CTOS 32 LDU LDDICT 256 LDU 256 LDU 256 LDU PLDDICT
			s6 PUSH 256 LDU 256 LDU ENDS

			// s7  seqno
			// s6  last_msg
			// s5  last_key
			// s4  third_key
			// s3  prev_key
			// s2  prev_msg
			// s1  intmsg_old_key
			// s0  intmsg_new_key

			s0 s3 PUSH2 EQUAL ERR_KEY_EXISTS THROWIF
			s0 s4 PUSH2 EQUAL ERR_KEY_EXISTS THROWIF
			s0 s5 PUSH2 EQUAL ERR_KEY_EXISTS THROWIF

			<{
				s1 s3 PUSH2 EQUAL <{ s3 XCHG0 }> PUSHCONT IFJMP
				s1 s4 PUSH2 EQUAL <{ s4 XCHG0 }> PUSHCONT IFJMP
				s1 s5 PUSH2 EQUAL <{ s5 XCHG0 }> PUSHCONT IFJMP
				ERR_KEY_NOT_FOUND THROW
			}> PUSHCONT EXECUTE

			2DROP 6 0 REVERSE
			NEWC 32 STU STDICT 256 STU 256 STU 256 STU STDICT ENDC
			POPROOT
		}> PUSHCONT IFJMP

		ERR_OP_UNKNOWN THROW
	}> PUSHCONT IFNOTJMP

	DUP FN_SEQNO INT EQUAL <{
		PUSHROOT CTOS 32 PLDU
		2 0 REVERSE 1 BLKDROP
	}> PUSHCONT IFJMP

	DUP FN_LASTMSG INT EQUAL <{
		PUSHROOT CTOS 32 LDU PLDDICT
		3 0 REVERSE 2 BLKDROP
	}> PUSHCONT IFJMP

	DUP FN_LASTKEY INT EQUAL <{
		PUSHROOT CTOS 32 LDU LDDICT 256 PLDU
		4 0 REVERSE 3 BLKDROP
	}> PUSHCONT IFJMP

	DUP FN_THIRDKEY INT EQUAL <{
		PUSHROOT CTOS 32 LDU LDDICT 256 LDU 256 PLDU
		5 0 REVERSE 4 BLKDROP
	}> PUSHCONT IFJMP

	DUP FN_PREVKEY INT EQUAL <{
		PUSHROOT CTOS 32 LDU LDDICT 256 LDU 256 LDU 256 PLDU
		6 0 REVERSE 5 BLKDROP
	}> PUSHCONT IFJMP

	DUP FN_PREVMSG INT EQUAL <{
		PUSHROOT CTOS 32 LDU LDDICT 256 LDU 256 LDU 256 LDU PLDDICT
		7 0 REVERSE 6 BLKDROP
	}> PUSHCONT IFJMP
}>c
