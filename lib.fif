"Asm.fif" include
"TonUtil.fif" include

// check if two addresses are equal
// wc1 hash1 wc2 hash2 -> result
{
	rot = -rot = and
} : addr=

// get Integer id of method String s:
// s -> id
{
	$>B crc16 0x10000 or
} : $>id

// serialize nullable Cell c into Builder b leaving new Builder b':
// b, c -> b'
{
	dict,
} : nullref,

// deserialize nullable Cell c from Slice s leaving remainder Slice s':
// s -> c, s'
{
	1 u@+ swap { ref@+ swap } { null swap } cond
} : nullref@+

// deserialize nullable Cell c from Slice s:
// s -> c
{
	nullref@+ drop
} : nullref@

{
	2dup <s s-fits? {
		swap false 1 u, swap <s s,
	} {
		swap true 1 u, swap ref,
	} cond
} : body,

{
	1 u@+ swap { ref@+ swap } { s>c } cond
} : body@

{
	"" swap {
		dup sbits 8 /c $@+ -rot $+ swap
		dup srefs 0 = {
			ref@ <s
		} ifnot
		dup empty?
	} until
	drop
} : comment@

{
	<s sbits 0 =
} : cancellation?@req

{
	<s 2 u@+ nip 1 i@
} : bounceable@msg

{
	<s 9 u@+ nip 8 i@+ 256 u@
} : addr@msg

{
	dup addr@msg rot bounceable@msg { 6 } { 7 } cond smca>$
} : addr@msg>$

{
	<s 17 u@+ nip 256 u@+ nip Gram@
} : amount@msg

{
	<s 17 u@+ nip 256 u@+ nip Gram@+ nip 106 u@+ nip body@
} : body@msg

{
	<s 32 u@
} : op@body

{
	op@body 0 =
} : simple_transfer?@body

{
	<s 32 u@+ swap 0 = { comment@ } { null } cond
} : simple_transfer_comment@body


{
	<s 32 u@
} : seqno@data

{
	<s 32 u@+ nip nullref@+ nip 32 B@+ 32 B@+ 32 B@

	2dup Bcmp -1 = { swap } if rot
	2dup Bcmp -1 = { swap } if -rot
	2dup Bcmp  1 = { swap } if
} : keys@data

{
	<s 32 u@+ nip nullref@+ 32 B@+ 32 B@+ 32 B@+ nullref@

	5 pick 2 pick B= {
		0 pick
	} {
		5 pick 4 pick B= {
			4 pick
		} {
			null
		} cond
	} cond

	6 -roll { drop } 6 times
} : my_request@data

{
	<s 32 u@+ nip nullref@+ 32 B@+ 32 B@+ 32 B@+ nullref@

	5 pick 2 pick B= {
		4 pick
	} {
		5 pick 4 pick B= {
			0 pick
		} {
			0 pick null? {
				4 pick
			} {
				0 pick
			} cond
		} cond
	} cond

	6 -roll { drop } 6 times
} : other_request1@data

{
	<s 32 u@+ nip nullref@+ 32 B@+ 32 B@+ 32 B@+ nullref@

	5 pick 2 pick B= {
		4 pick null? { null } { 3 pick } cond
	} {
		5 pick 4 pick B= {
			0 pick null? { null } { 1 pick } cond
		} {
			0 pick null? {
				4 pick null? { null } { 3 pick } cond
			} {
				0 pick null? { null } { 1 pick } cond
			} cond
		} cond
	} cond

	6 -roll { drop } 6 times
} : other_request1_key@data

{
	<s 32 u@+ nip nullref@+ 32 B@+ 32 B@+ 32 B@+ nullref@

	5 pick 3 pick B= {
		4 pick
	} {
		null
	} cond

	6 -roll { drop } 6 times
} : other_request2@data

{
	<s 32 u@+ nip nullref@+ 32 B@+ 32 B@+ 32 B@+ nullref@

	5 pick 3 pick B= {
		4 pick null? { null } { 3 pick } cond
	} {
		null
	} cond

	6 -roll { drop } 6 times
} : other_request2_key@data
